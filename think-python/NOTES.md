# Think Python - Allen B. Downey

> üí° ***Anota√ß√µes e resumos***

## Chapter 12

- Tuples are an ***immutable sequence of elements***
    - Tuples can be defined in the following forms:
    
    ```python
    >>> t = ' a' , ' b' , ' c' , ' d' , ' e'
    >>> t = (' a' , ' b' , ' c' , ' d' , ' e' )
    >>> t1 = ' a' ,
    >>> t = tuple(' lupins' ) ‚Üí (' l' , ' u' , ' p' , ' i' , ' n' , ' s' )
    ```
    
    - You can use a list of tuples to create a new dict:
    
    ```python
    >>> t = [(' a' , 0), (' c' , 2), (' b' , 1)] 
    >>> d = dict(t)
    ```
    
- ***Tuples assignments*** ‚Üí an assignment with a sequence on the right side and a tuple of variables on the left
    
    ```python
    a, b = b, a
    ```
    
    - All the expressions on the right side are evaluated, and then its elements are assigned to the variables on the left. It‚Äôs a more concise way to write:
    
    ```python
    temp = a
    a = b
    b = temp
    ```
    
- ***Gather***: an operation that collects multiple arguments into a tuple. Usually, a parameter name that begins with *******.
    
    ```python
    def printall(*args):
        print(args)
    
    printall(1, 2, 3)
    >>> (1, 2, 3)
    ```
    
- ***Scatter***: an operation that unpacks a sequence of values as single ones. Using a function as example, we would have:
    
    ```python
    t = (7, 3)
    
    # divmod takes exactly two arguments. see [docs](https://docs.python.org/3/library/functions.html#divmod)
    divmod(*t)
    >>> (2, 1)
    
    # The same as using:
    divmod(7, 3)
    >>> (2, 1)
    ```
    
- ***zip***: a built-in function that takes two or more sequence and interleaves them. Returns a ***zip object*** which is an ***iterator***, an object that iterates through a sequence. Their difference to a list it‚Äôs you can‚Äôt use indexes to select their elements
    
    ```python
    seq1 = 'Vitor'
    seq2 = 'Baldo'
    
    list(zip(seq1, seq2))
    >>> [('V', 'B'), ('i', 'a'), ('t', 'l'), ('o', 'd'), ('r', 'o')]
    
    # If the sequences are from different sizes, the zip keeps the size of the shorter one
    
    seq3 = 'Casa' 
    seq4 = 'Gol'
    
    list(zip(seq3, seq4))
    >>> [('C', 'G'), ('a', 'o'), ('s', 'l')]
    ```
    
- Combining ***zip***, ***for loops*** and ***tuple assignments*** we get a useful idiom for traversing two (or more) sequences at the same time:
    
    ```python
    def has_match(t, l):
    	for x, y in zip(t, l):
    		if x == y:
    			return True
    	return False
    ```
    
- ***Enumerate***: useful built-in function to traverse the elements of a sequence and their indices:
    
    ```python
    for index, element in enumarate('Vitor'):
    	print(index, element)
    
    >>> 0 'V'
    >>> 1 'i'
    >>> 2 't'
    >>> 3 'o'
    >>> 4 'r'
    ```
    

## Chapter 13


- ‚Äú*Pseudorandom numbers are not truly random because they are generated by a deterministic computation, but just by looking at the numbers it is all but impossible to distinguish them from random.‚Äù*
- The ***random*** module also provides functions to generate values from continuous distributions.
- Optional parameters:
    
    ```python
    def print_most(hist: dict, num: int=10):
    		...do something using num...
    ```
    
    - This function has the default value of 10 for the parameter *num*. If we call the function as ***print_most(d, num=20)***, the 20 will override the default value.
    - All the required parameters have to come first in a function call.
- ***Markov Analysis:***
    - A way of measure the relationship of words in a text. It maps prefixes to suffixes, and it is useful to generate a random text.
- The ***profile*** module can identify the places in a program that take the most time.
    
        

## Chapter 14


- When referencing a file without using its ***absolute path** (home_dir/parent_folder/file.txt)*, we are using a ***relative path***. That is, a path tha is relative to the current working directory
- The module ***dbm*** provides an interface for creating and updating database files. But be aware that the keys in the database created by dbm are ***bytes objects or strings***, and some difficulties can arise from that.
- A way of solve the previously announced problem is to use the ***pickle module***, that translates almost any type of object into a string suitable for storage in a database. ‚Üí The combination of ***dbm*** and ***pickle*** is so common that was encapsulated in a module called ***shelve***.
- To run shell commands in python we can use a ***pipe object***:
    
    ```python
    cmd = 'ls -l'
    fp = os.popen(cmd)
    ```
    
    - `popen` is deprecated. We should use the `subprocess` module.
- Most Unix systems provide a command called ***md5sum*** that reads the contents of a file and computes a ‚Äúchecksum‚Äù

## Chapter 15


- A ***class*** is a programmer-defined type. A class definition creates a new ***class object***, that is, an object that holds information about a programmer-defined class.
- Creating a new object is called ***instantiation***, and the object is an ***instance*** of the class.
    
    ```python
    class Point:
    	pass
    
    blank = Point() # blank is an instance of the class Point
    ```
    
- Objects have ***attributes***, that is, values within them:
    
    ```python
    blank.x = 3
    blank.y = 4
    ```
    
- An object that is an attribute of another object is ***embedded***.
- ***Objects are mutable***
- Since objects are mutable. The module ***copy*** provides functions to avoid the errors caused by aliasing. The functions covered in this chapter where ***copy.copy***, which provides a ***shallow copy*** of objects and ***copy.deepcopy***, I guess the name is self-explanatory.
- A shallow copy means that objects embedded will not be copied.
- For instances, the default behavior of the == operator is the same as the ***is*** operator.
- If you are not sure whether an object has a particular attribute, you can use the built-in function ***hasattr***.

## Chapter 16

- ***Prototype and Patch*** ‚Üí a way of tackling a complex problem by starting with a simple prototype and incrementally dealing with the complications
- ***Designed Development*** ‚Üí a development plan that involver thinking about the problem deeply enough so you can come out with a simpler solution.
- ***Functional Programming*** ‚Üí a style of program design in which the majority of functions are pure.

## Chapter 17

- *Objects often represent things in the real world, and methods often correspond to the way things in the real world interact*.
- A **method** is a function that is associated with a particular class.
    ```python
    class Time:
        """Represents the time of day."""

        def __init__(self, hour: int = 0, minute: int = 0, second: int = 0):

            self.hour = hour
            self.minute = minute
            self.second = second
        
        def __str__(self):
            return f"{self.hour:02d}:{self.minute:02d}:{self.second:02d}"
        
        def print_time(self):
            print(f"{self.hour:02d}:{self.minute:02d}:{self.second:02d}")
    ```
    - The `__init__` method is a special method that gets invoked when an object is instantiated.
    - The `__str__` method also is a special method that return a string representation of an object.
- By convention, the first parameter of a method is called self. This happens because in object-oriented programming the objects are the *active agents*. *"A method invocation like `Time.print_time()` says 'Hey Time! Please print yourself.'"*
- It is possible to modify the behavior of python operators writing special method such as `__add__` ($+$),`__lq__` ($<$), `__sub__` ($-$), `__mul__`($\times$), etc. This is called ***operator overloading***. 
- ***Type-based dispatch***: an operation that dispatches the computation to different methods based on the type of the arguments.
- Functions that work with several types are called ***polymorphic***

- One of the goals of object-oriented design is to make software more maintainable. ***"A design principle that helps achieve that goal is to keep interfaces separate from implementations."***
    - In practical terms, that means that a class method should not depend on how the attributes of that class are represented. That is, the `Time.print_time()` method defined above should be a ***polymorphic*** function and should work regardless of how the `Time` object attributes are represented.
    - This [answer](https://softwareengineering.stackexchange.com/questions/306402/if-class-is-to-define-attributes-and-methods-and-interface-is-to-define-a-set/306416) helped me think this through.